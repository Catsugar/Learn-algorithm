<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Symmetric Difference</title>
</head>

<body>
<script>
function sym(args) {
	/*创建一个函数，接受两个或多个数组，返回所给数组的 对等差分(symmetric difference) (△ or ⊕)数组.
给出两个集合 (如集合 A = {1, 2, 3} 和集合 B = {2, 3, 4}), 
而数学术语 "对等差分" 的集合就是指由所有只在两个集合其中之一的元素组成的集合(A △ B = C = {1, 4}). 对于传入的额外集合 (如 D = {2, 3}), 
你应该安装前面原则求前两个集合的结果与新集合的对等差分集合 (C △ D = {1, 4} △ {2, 3} = {1, 2, 3, 4}).*/
	
	
 //标准答案
  /*var arr = [];
  for(var i = 0; i < arguments.length; i++){
    arr.push(arguments[i]);
  }
  var temp = arr.reduce(function(prev,cur,index,array){
    var a = prev.filter(function(item){
      return cur.indexOf(item) < 0;
    });
    var b = cur.filter(function(item){
      return prev.indexOf(item) < 0;
    });
    return a.concat(b);
  });
  return temp.filter(function(item,index,array){
    return array.indexOf(item) == index;
  });*/
  //我的作法,比较蠢
  var arr = [];
  var newarr=[];
  for(var i = 0; i < arguments.length; i++){
    arr.push(arguments[i]);
  }
  //扁平化
  var result=[];
  for(var i=0; i<arr.length; i++){
	  if(Array.isArray(arr[i])){
		  result=result.concat(arr[i]);
	  }else{
		  result.push(arr[i]);
	  }
  }
  for(var i = 0; i < result.length; i++){
	  for(var j = i+1; j < result.length; j++){
		  console.log(result[i]+"..."+result[j]);
		  if(result[i]==result[j]){
		      newarr.push(result[i]);//找出重复的树
		  }
	  }
	  
  }
  arr=result.filter(function(item){
    return newarr.indexOf(item) < 0;
  });
  alert(arr);
  return arr;
  
}
sym([1, 2, 3], [5, 2, 1, 4]);
</script>
</body>
</html>
